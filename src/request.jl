# states of request case keises
# opened
# closed
function trequest(d, mb) # participant iniciates a request
    @unpack tree, mbs, keises = d
    if mb["step"]=="0"
        if mb["token"]<0 
            sendms("request_not_enough_tokens", mb)
            tbegin(mb)
            println("suspiciously many requests generated by same person $(mb["id"])")
        else #if !haskey(mb,"requestid") ||
            mb["path"] = "0"
            mb["step"] = "request"
            sendms("request_enter_question", mb)
        end
        return
    end

 # The text of request was entered
    mb["requestid"] = now()
    keises[mb["requestid"]] = Dict("getter"=>mb,"txt"=>deepcopy(mb["txt"]),"giver"=>[],"state"=>"opened","requested_id"=>[],
                                    "msgtodelete"=>[])
    keyboard = [[dc("request_keyb_send", mb), "propagate()",dc("request_keyb_select", mb), "traversetree(),0"]]
    sendms("request_send_request_or_enter", mb, keyboard = keyboard)
    sendMessage(chat_id = -729825915, text = string("Request from ", mb["first_name"])) # message to Talkon track group
end

function propagate(d::DataBase, mb) 
    @unpack mbs, keises, tree = d
    keypath = join(mb["path"])
    if length(mb["path"])==1
        keypath = "0"
    else
        while isempty(tree[keypath]["dav_id"])
            if length(tree[keypath]["steps"])<2
                keypath = "0"
                break
            else
                keypath = join(tree[keypath]["steps"][1:end-1])
            end
        end
    end
    sendms("request_wait", mb)
    # TODO: redundant keis? TS: Do not understand the question
    keis = keises[mb["requestid"]]
    subject = join(mb["path"][2:end], "/")
    if isempty(subject)
        subject = dc("request_subject_all", mb)
    end
    keis["subject"] = subject
    keis["dav_id"] = tree[keypath]["dav_id"]
    sendrequest(d, mb)
end

function sendrequest(d::DataBase, mb) # the request is broadcasted
    @unpack mbs, keises = d

    keis = keises[mb["requestid"]]
    if length(keis["requested_id"]) == length(keis["dav_id"])
        msg = string(dc("sendrequest_repeated_request_text_1", mb), (keis["txt"]), dc("sendrequest_request_text_2", mb), 
                        keis["subject"], dc("sendrequest_request_text_3", mb))
        keis["requested_id"] = []
    else
        msg = string(dc("sendrequest_request_text_1", mb), (keis["txt"]), dc("sendrequest_request_text_2", mb),
                        keis["subject"], dc("sendrequest_request_text_3", mb))
    end
    i = 1
    for id in shuffle(keis["dav_id"])
        if id == mb["id"] || any(keis["requested_id"].==id) || !any(mbs[id]["step"] .== ["0", "enter"]) || !any(mb["ln"] .== mb["spoken_lns"])
            continue
        end
        keyboard = [[dc("sendrequest_keyb_accept", mbs[id]),"dealkeis(),accept",
                    dc("sendrequest_keyb_decline", mbs[id]),"dealkeis(),decline"]]
        msgid = try
            sendMessage(chat_id = id, text = msg, reply_markup = tik(keyboard))
        catch
            println("Didn't manage to send to $id, $(mbs[id]["first_name"])")
            continue
        end
        mbs[id]["step"] = "requested"
        mbs[id]["getterid"] = mb["id"]
        push!(keis["requested_id"], id)
        push!(keis["msgtodelete"],msgid["message_id"])
        i=i+1
        if length(i) > 4 #this is one portion of sent requests
            break
        end
    end
end

function dealkeis(d, mb, action)
    @unpack mbs, keises, groups = d
    if action == "accept"
        mbg = mbs[mb["getterid"]]
        mb["requestid"]=mbg["requestid"]
        keis = keises[mbg["requestid"]]           
        if mbg["step"] == "request"
            keis["group"] = getgroup(groups)
            keis["group"].second["state"] = "notfree"
            msg = "$(dc("dealkeis_discuss_issue", mbg))$(keis["group"].second["link"])"
            msgid=sendMessage(chat_id = mb["getterid"], text = msg)
            push!(keis["msgtodelete"],msgid["message_id"])
            mbg["step"] = "accepted"
            msg = string(dc("sendrequest_request_text_1", mbg), (keis["txt"]), dc("sendrequest_request_text_2", mbg), 
                            keis["subject"], dc("sendrequest_request_text_3", mbg)) 
            sendMessage(chat_id = keis["group"].first, text = msg) 
            keyboard = [[dc("dealkeis_keyb_close_case", mbg),"closekeis()"]]
            ms = sendms("dealkeis_close_meeting", mbg, chat_id = keis["group"].first, keyboard = keyboard) # the bottum in a group 
            pinChatMessage(chat_id = keis["group"].first, message_id = ms["message_id"])
            if mbg["id"] != 5090964479 # if not Talkininkas, the owner of the group
                unbanChatMember(chat_id = keis["group"].first, user_id = mbg["id"])
            end
        elseif mbg["step"] != "accepted"
            return
        end
        msgid=sendms("$(dc("dealkeis_discuss_issue", mb))$(keis["group"].second["link"])", mb)
        push!(keis["msgtodelete"],msgid["message_id"])
        push!(keis["giver"], mb["id"])
        keis["state"] = "accepted"
        if mb["id"] != 5090964479 # if not owner of the group
            unbanChatMember(chat_id = keis["group"].first,user_id = mb["id"])
        end
    elseif action == "decline"
        mb["getterid"] = nothing
        tbegin(mb)
    end
end

function chekeis(d)
    @unpack keises, mbs = d
    n = now()
    for k in keys(keises)
        keis=keises[k]
        if (k+Minute(30))<n
            if keis["state"]=="closed"
                continue
            else
                closekeis(d, k)
            end
        end
        if keis["state"] == "opened" && (k+Minute(1)) < n
            mb = mbs[keis["getter"]["id"]]
            if (k+Minute(7))<n
                closekeis(d, k)
            else
                if haskey(keis,"dav_id")
                    sendrequest(d, mb)
                else
                    keis["state"] = "closed"
                    tbegin(mb)
                end
            end
        end
        if keis["state"] == "accepted" && length(keis["giver"])>3 || (k+Minute(5)) < n 
            for msid in keis["msgtodelete"]
                try
                    deleteMessage(chat_id = mb["id"],message_id = msid)
                catch
                end
            end
            keis["msgtodelete"]=[]
        end
    end
    
end

function closekeis(d, k)
    @unpack keises, mbs = d
    if !any(keys(keises) .== k)
        return
    end
    keis = keises[k]
    if keis["state"] == "closed"
        return
    end
# deal with getter    
    mb = mbs[keis["getter"]["id"]]
    mb["step"]="0"
    if keis["state"] != "accepted"
        keis["state"] = "closed"
        sendms("closekeis_didn't_find_help.", mb)
        tbegin(mb)
        return
    end
    keis["state"] = "closed"
    sendms("closekeis_meeting_closed", mb, chat_id = keis["group"].first)
    ChatMember = getChatMember(chat_id = keis["group"].first, user_id = mb["id"])
    if !(ChatMember["status"] == "left") && !(ChatMember["status"] == "creator")
        banChatMember(chat_id = keis["group"].first, user_id = mb["id"], revoke_messages = true)
    end
    mb["token"] = mb["token"]-1
    tfg = 1/(length(keis["giver"])+0.2)
    get_tokens(mb)
    keyboard = [[dc("closekeis_yes", mb), "valuableyesno(),yes", dc("closekeis_no", mb), "valuableyesno(),no"]]
    sendms("closekeis_meeting_usefull?", mb, keyboard = keyboard)
# deal with givers
    for gid in keis["giver"]
        mb = mbs[gid]
        chm = getChatMember(chat_id = keis["group"].first, user_id = gid)
        mbs[gid]["token"] += tfg
        sendms("closekeis_thank_you", mb)
        if !(chm["status"] == "left") && !(chm["status"] == "creator")
            banChatMember(chat_id = keis["group"].first, user_id = gid, revoke_messages=true)
        end
        if !(chm["status"] == "left")
            get_tokens(mb)
        end
        tbegin(mb)
    end
    keis["group"].second["state"] = "free"
end
